# Исправление ошибок гидратации в Next.js

## Проблема
Ошибка "Hydration failed because the initial UI does not match what was rendered on the server" возникает, когда HTML, сгенерированный на сервере, не совпадает с тем, что рендерится на клиенте.

## Причины и решения

### 1. Использование localStorage в CartContext
**Проблема**: CartContext пытался получить доступ к localStorage во время серверного рендеринга.

**Решение**: 
- Добавлено состояние `isClient` для отслеживания клиентской инициализации
- Все операции с localStorage выполняются только после установки `isClient = true`
- Предоставлен fallback провайдер для серверного рендеринга

### 2. Условный рендеринг в Header
**Проблема**: Компонент Header использовал состояние `mounted` для условного отображения количества товаров в корзине.

**Решение**:
- Удалено состояние `mounted` из Header
- Функции `getTotalItems()` и `getTotalPrice()` теперь возвращают 0 на сервере и правильные значения на клиенте
- Создан компонент `ClientOnly` для случаев, когда нужен условный рендеринг

### 3. Безопасная работа с браузерными API
**Проблема**: Прямое обращение к `window` и `document` во время SSR.

**Решение**:
- Все обращения к браузерным API обернуты в проверки `typeof window !== 'undefined'`
- Использование `useEffect` для операций, которые должны выполняться только на клиенте

## Внесенные изменения

### CartContext.js
- Добавлено состояние `isClient`
- Fallback провайдер для SSR
- Безопасная работа с localStorage

### Header.js
- Удалено состояние `mounted`
- Упрощена логика отображения количества товаров

### ClientOnly.js
- Создан компонент для условного рендеринга на клиенте

## Проверка исправлений

1. Запустите проект: `npm run dev`
2. Откройте браузер и перейдите на главную страницу
3. Проверьте консоль браузера на наличие ошибок гидратации
4. Убедитесь, что корзина работает корректно

## Дополнительные рекомендации

1. Всегда проверяйте доступность браузерных API перед их использованием
2. Используйте `useEffect` для операций, которые должны выполняться только на клиенте
3. Предоставляйте fallback значения для серверного рендеринга
4. Избегайте условного рендеринга, основанного на клиентском состоянии, без соответствующих fallback'ов
